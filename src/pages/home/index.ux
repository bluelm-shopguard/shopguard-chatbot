<import name="svg-icon" src="../../components/ui/svg-icon.ux"></import>

<template>
  <div class="page">
    <!-- Header -->
    <div class="chat-header">
      <div class="header-button" onclick="openSidebar">
        <svg-icon name="align-justify" size="24" color="#333333" darkColor="#FFFFFF"></svg-icon>
      </div>
      <text class="chat-header-title">BlueLM Shopguard</text>
      <div class="header-button" onclick="startNewChat">
        <svg-icon name="circle-plus" size="24" color="#333333" darkColor="#FFFFFF"></svg-icon>
      </div>
    </div>

    <!-- Main Content Area -->
    <div class="chat-content">
      <div class="chat-welcome" show="{{showWelcome}}">
        <div class="logo-container">
          <!-- TODO use logo icon instead of text -->
          <text class="logo-text">SG</text>
        </div>
        <text class="welcome-title">ËìùÂøÉË¥≠Áâ©Èò≤ËØàÈ™óÂä©Êâã</text>
        <div class="welcome-message-container">
          <richtext type="html" class="welcome-message">
            {{formattedWelcomeMessage}}
          </richtext>
        </div>
      </div>

      <!-- Chat Messages Area -->
      <list class="chat-messages-list" id="chat-content-list" show="{{!showWelcome}}">
        <block for="{{messages}}">
          <list-item type="message">
            <div class="{{$item.role === 'user' ? 'user-message' : 'bot-message'}}">
              <div class="message-timestamp">
                <text class="timestamp-text">{{ $item.timestamp }}</text>
              </div>
              <div class="message-content-container">
                <!-- Show image if present -->
                <image class="message-image" src="{{$item.imageData}}" show="{{$item.imageData !== undefined && $item.imageData !== null}}"></image>
                <div class="message-text-wrapper">
                  <text class="message-text-content">{{ $item.content }}</text>
                </div>
              </div>
            </div>
          </list-item>
        </block>
      </list>
    </div>

    <!-- Input Area - Redesigned to match webapp -->
    <div class="chat-input-area">
      <!-- Toolbar now positioned above the input area -->
      <div class="toolbar-row">
        <div class="toolbar-button" onclick="handleImageUpload">
          <div class="icon-container">
            <text class="toolbar-icon">üì∑</text>
          </div>
          <text class="toolbar-text">ÂõæÁâá</text>
        </div>
        <div class="toolbar-button" onclick="handleTakePhoto">
          <div class="icon-container">
            <text class="toolbar-icon">üì∏</text>
          </div>
          <text class="toolbar-text">ÊãçÁÖß</text>
        </div>
      </div>

      <div class="input-area-wrapper">
        <input id="chat-input" class="text-input" type="text" placeholder="ÂèëÊ∂àÊÅØÁªôÊàëÂàÜÊûê‰∏Ä‰∏ã..." value="{{message}}"
          onchange="handleInputChange" disabled="{{isProcessingMessage}}" />
        <div class="send-button" onclick="sendMessage" style="opacity: {{isProcessingMessage ? '0.5' : '1'}}">
          <text class="send-icon">‚Üë</text>
        </div>
      </div>
      
      <!-- Image preview container -->
      <div class="image-preview-container" show="{{currentImageData !== null}}">
        <image class="preview-image" src="{{currentImageData}}"></image>
        <div class="remove-image-button" onclick="removeSelectedImage">
          <text class="remove-icon">‚úï</text>
        </div>
      </div>

      <!-- Loading indicator - only shown when actively processing a message AND there's actually a message to show -->
      <div class="loading-indicator" show="{{isProcessingMessage && loadingText !== ''}}">
        <text class="loading-text">{{loadingText}}</text>
      </div>
    </div>

    <!-- Sidebar Component -->
    <div class="sidebar-overlay" show="{{sidebarActive}}" onclick="closeSidebar"></div>

    <div class="sidebar" style="transform: {{sidebarActive ? 'translateX(0)' : 'translateX(-100%)'}}">
      <div class="sidebar-header">
        <text class="sidebar-title">ÂéÜÂè≤ÂØπËØù</text>
        <div class="header-button close-button" onclick="closeSidebar">
          <text class="header-icon">‚úï</text>
        </div>
      </div>

      <div class="sidebar-content">
        <list class="conversation-list" if="{{conversations.length > 0}}">
          <block for="{{conversations}}">
            <list-item type="conversation" onclick="loadConversation($item.id)">
              <div class="conversation-item">
                <div class="conversation-info">
                  <text class="conversation-title">{{$item.title}}</text>
                  <text class="conversation-preview">{{$item.preview}}</text>
                  <text class="conversation-timestamp">{{$item.displayDate}}</text>
                </div>
                <div class="delete-conversation-btn" onclick="deleteConversation($item.id, $event)">
                  <text class="delete-icon">üóëÔ∏è</text>
                </div>
              </div>
            </list-item>
          </block>
        </list>
        <text class="sidebar-empty-text" if="{{conversations.length === 0}}">ÊöÇÊó†ÂéÜÂè≤ÂØπËØù</text>
      </div>

      <div class="sidebar-footer">
        <!-- TODO implement user login -->
        <!-- TODO implement user database including chat history -->
        <div class="account-info">
          <div class="account-avatar">
            <text class="avatar-text">üë§</text>
          </div>
          <text class="account-name">Ê∏∏ÂÆ¢</text>
        </div>
        <div class="settings-button" onclick="navigateToSettings">
          <text class="settings-icon">‚öôÔ∏è</text>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { callChatbotAPI } from "../../helper/api-service";
import SYSTEM from "../../helper/system-settings";
import media from '@system.media';
import formattedText from "../../components/ui/formatted-text";

export default {
	// Register the formatted-text component
	components: {
		'formatted-text': formattedText
	},
	data: {
		message: "",
		messages: [], // Array to store chat messages
		conversations: [], // Array to store conversation history
		currentConversationId: null, // Current conversation ID
		showWelcome: true, // Whether to show welcome screen
		isProcessingMessage: false,
		currentImageData: null,
		sidebarActive: false,
		loadingText: "", // IMPORTANT: Must initialize as empty to avoid showing loading message at startup
		processingProgress: 0, // Progress indicator for long operations
		welcomeMessage: "ÈÅáÂà∞ÂèØÁñëÂïÜÂìÅ„ÄÅÂçñÂÆ∂Êàñ‰ªòÊ¨æÊñπÂºèÔºüÈöèÊó∂ÂèëÁªôÊàëÂàÜÊûê„ÄÇÊó†ËÆ∫ÊòØÂïÜÂìÅ**Êà™Âõæ**„ÄÅ**ÈìæÊé•**ËøòÊòØ**ËÅäÂ§©ËÆ∞ÂΩï**ÔºåÊàëÈÉΩ‰ºöÂ∏Æ‰Ω†ËØÜÂà´È£éÈô©ÔºåÊèê‰æõÊòéÁ°ÆÁöÑ\"**ËôöÂÅáËØàÈ™óÈ£éÈô©ÊòüÁ∫ß**\"ÂíåÂª∫ËÆÆÔºåËÆ©Êàë‰ª¨‰∏ÄËµ∑ÂÆâÂøÉË¥≠Áâ©‰∏çË∏©ÂùëÔºÅ",
		_isDeletingConversation: null, // Internal flag to track conversation deletion
	},

	computed: {
		formattedWelcomeMessage() {
			// Format welcome message using markdown helper
			if (this.$app.$def && this.$app.$def.markdownHelper) {
				return this.$app.$def.markdownHelper.formatMessageContent(this.welcomeMessage);
			}
			return this.welcomeMessage;
		}
	},

	onInit() {
		// Initialize chat state
		this.showWelcome = true;
		this.messages = [];
		this.isProcessingMessage = false;  // Explicitly set to false to ensure loading indicator doesn't show at startup
		this.currentImageData = null;
		this.sidebarActive = false;
		this.loadingText = "";  // Set to empty to ensure loading text doesn't show at startup
		this.currentConversationId = null;
		
		// Load conversation history
		this.loadConversationHistory();
	},
	
	loadConversationHistory: async function() {
		try {
			// Access chat history helper through app instance
			const chatHistoryHelper = this.$app.$def.chatHistoryHelper;
			
			// Initialize storage
			await chatHistoryHelper.initializeStorage();
			
			// Load conversation index
			const conversationIndex = await chatHistoryHelper.loadConversationIndex();
			
			// Format dates for display
			this.conversations = conversationIndex.map(conv => {
				return {
					...conv,
					displayDate: chatHistoryHelper.formatConversationDate(conv.timestamp)
				};
			});
			
			console.log(`Loaded ${this.conversations.length} conversations`);
		} catch (error) {
			console.error('Failed to load conversation history:', error);
			this.$app.$def.showToast('Êó†Ê≥ïÂä†ËΩΩÂéÜÂè≤ÂØπËØù');
		}
	},

	handleInputChange: function (e) {
		this.message = e.value;
	},

	openSidebar: function () {
		this.sidebarActive = true;
	},

	closeSidebar: function () {
		this.sidebarActive = false;
	},

	startNewChat: async function () {
		// Save current conversation if it exists and has messages
		if (this.currentConversationId && this.messages.length > 0) {
			await this.saveCurrentConversation();
		}
		
		// Reset chat state completely
		this.message = "";
		this.currentImageData = null;
		this.showWelcome = true;
		this.messages = [];
		this.isProcessingMessage = false;  // Explicitly set to false
		this.loadingText = "";  // Clear loading text
		
		// Generate a new conversation ID
		this.currentConversationId = this.$app.$def.chatHistoryHelper.generateConversationId();
		console.log('Starting new conversation with ID:', this.currentConversationId);
		
		// Reset UI state properly
		this.resetUIState();

		this.$app.$def.showToast("ÂºÄÂßãÊñ∞ÁöÑÂØπËØù");
	},
	
	// Save the current conversation to storage
	saveCurrentConversation: async function() {
		if (!this.currentConversationId || this.messages.length === 0) {
			return;
		}
		
		try {
			const chatHistoryHelper = this.$app.$def.chatHistoryHelper;
			
			// Create conversation object
			const conversation = {
				id: this.currentConversationId,
				title: chatHistoryHelper.generateConversationTitle(this.messages),
				preview: chatHistoryHelper.generateConversationPreview(this.messages),
				timestamp: new Date().toISOString(),
				messages: this.messages
			};
			
			// Save to storage
			await chatHistoryHelper.saveConversation(conversation);
			
			// Reload the conversation list
			await this.loadConversationHistory();
			
			console.log('Conversation saved:', this.currentConversationId);
		} catch (error) {
			console.error('Failed to save conversation:', error);
			this.$app.$def.showToast('Êó†Ê≥ï‰øùÂ≠òÂØπËØù');
		}
	},
	
	// Load a conversation from history
	loadConversation: async function(id, event) {
		// If event is provided, stop propagation to prevent click on the parent item
		if (event) {
			event.stopPropagation();
		}
		
		// Check if this is being called while a conversation is being deleted
		// This helps prevent the "ËØ•ÂØπËØùÂ∑≤‰∏çÂ≠òÂú®" message when we know we just deleted it
		if (this._isDeletingConversation === id) {
			console.log(`Ignoring loadConversation for ${id} as it's currently being deleted`);
			return; // Skip loading as we know it's being deleted
		}
		
		// First check if the conversation exists in the current list
		const conversationExists = this.conversations.some(conv => conv.id === id);
		if (!conversationExists) {
			console.log(`Conversation ${id} not found in the list, might have been deleted`);
			
			// Reset to welcome screen as conversation doesn't exist anymore
			this.message = "";
			this.currentImageData = null;
			this.showWelcome = true;
			this.messages = [];
			this.isProcessingMessage = false;
			this.loadingText = "";
			
			// Generate a new conversation ID
			this.currentConversationId = this.$app.$def.chatHistoryHelper.generateConversationId();
			
			// Reset UI state properly
			this.resetUIState();
			
			// Check if we're in a deletion process before showing message
			if (!this._isDeletingConversation) {
				this.$app.$def.showToast('ËØ•ÂØπËØùÂ∑≤‰∏çÂ≠òÂú®');
			}
			
			return; // Don't attempt to load a conversation that doesn't exist
		}
		
		// Save current conversation if it exists and has messages
		if (this.currentConversationId && this.messages.length > 0 && this.currentConversationId !== id) {
			await this.saveCurrentConversation();
		}
		
		try {
			// Close the sidebar
			this.closeSidebar();
			
			// Load the selected conversation
			const conversation = await this.$app.$def.chatHistoryHelper.loadConversation(id);
			
			// Additional validation: Make sure we have a valid conversation object
			if (!conversation || !conversation.messages) {
				throw new Error('Invalid conversation format');
			}
			
			// Update the UI
			this.currentConversationId = id;
			this.messages = conversation.messages || [];
			this.showWelcome = false;
			
			console.log(`Loaded conversation ${id} with ${this.messages.length} messages`);
			
			// Scroll to the bottom to show latest message
			this.$element && this.$element("chat-content-list") && 
			this.$element("chat-content-list").scrollTo({
				index: this.messages.length - 1,
			});
		} catch (error) {
			console.error('Failed to load conversation:', error);
			
			// Check if the error is related to a file not found (code 301)
			const isFileNotFound = error.message && error.message.includes('301');
			
			// Only show toast message if we're not in the middle of a deletion
			if (!this._isDeletingConversation) {
				// Show appropriate message
				if (isFileNotFound) {
					this.$app.$def.showToast('ËØ•ÂØπËØùÂ∑≤‰∏çÂ≠òÂú®');
				} else {
					this.$app.$def.showToast('Êó†Ê≥ïÂä†ËΩΩÂØπËØù');
				}
			}
			
			// If there was an error loading the conversation, reset to welcome screen
			this.message = "";
			this.currentImageData = null;
			this.showWelcome = true;
			this.messages = [];
			this.isProcessingMessage = false;
			this.loadingText = "";
			this.currentConversationId = this.$app.$def.chatHistoryHelper.generateConversationId();
			this.resetUIState();
		}
	},
	
	// Delete a conversation
	deleteConversation: async function(id, event) {
		// Make sure to completely stop event propagation to prevent the parent click handler
		if (event) {
			event.stopPropagation();
			// Prevent any further event handling to be absolutely sure
			event.preventDefault && event.preventDefault();
		}
		
		// Set flag to indicate this conversation is being deleted
		// This helps prevent the "ËØ•ÂØπËØùÂ∑≤‰∏çÂ≠òÂú®" message when we're intentionally deleting
		this._isDeletingConversation = id;
		
		try {
			// First check if we need to reset UI (if this is the current conversation)
			const isCurrentConversation = (this.currentConversationId === id);
			if (isCurrentConversation) {
				// Reset the UI state completely BEFORE deleting to avoid any loading attempts
				this.message = "";
				this.currentImageData = null;
				this.showWelcome = true;
				this.messages = [];
				this.isProcessingMessage = false;
				this.loadingText = "";
				
				// Generate a new conversation ID immediately
				this.currentConversationId = this.$app.$def.chatHistoryHelper.generateConversationId();
				
				// Reset UI state properly
				this.resetUIState();
			}
			
			// Delete the conversation
			await this.$app.$def.chatHistoryHelper.deleteConversation(id);
			
			// Reload the conversation list
			await this.loadConversationHistory();
			
			console.log('Conversation deleted:', id);
			this.$app.$def.showToast('Â∑≤Âà†Èô§ÂØπËØù');
		} catch (error) {
			console.error('Failed to delete conversation:', error);
			this.$app.$def.showToast('Êó†Ê≥ïÂà†Èô§ÂØπËØù');
		} finally {
			// Clear the deletion flag
			setTimeout(() => {
				this._isDeletingConversation = null;
			}, 500); // Small timeout to allow any pending events to complete
		}
		
		// Explicitly return false to prevent any further event propagation
		return false;
	},

	handleImageUpload: function () {
		// Use QuickApp's media module to pick an image
		media.pickImage({
			success: (data) => {
				if (data && data.uri) {
					console.log("Image selected:", data.uri);
					console.log("Image details:", JSON.stringify(data));
					
					// Check file size if available
					if (data.size) {
						const fileSizeMB = (data.size / (1024 * 1024)).toFixed(2);
						console.log(`Image size: ${fileSizeMB}MB`);
						
						if (data.size > 5 * 1024 * 1024) { // 5MB
							this.$app.$def.showToast(`ÂõæÁâáËæÉÂ§ß(${fileSizeMB}MB)ÔºåÂ§ÑÁêÜÂèØËÉΩÈúÄË¶ÅÊõ¥ÈïøÊó∂Èó¥`);
						}
					}
					
					// Store the entire image data object (not just URI)
					this.currentImageData = data;
					this.$app.$def.showToast("ÂõæÁâáÂ∑≤ÈÄâÊã©");
					
					// Log the stored data
					console.log("Image data stored in currentImageData:", JSON.stringify(this.currentImageData));
				}
			},
			fail: (data, code) => {
				console.log(`Image pick failed, code = ${code}, data = ${data}`);
				this.$app.$def.showToast("ÈÄâÊã©ÂõæÁâáÂ§±Ë¥•");
			},
			cancel: () => {
				console.log("Image pick cancelled");
			}
		});
	},

	handleTakePhoto: function() {
		// Use the device camera to take a photo
		media.takePhoto({
			success: (data) => {
				if (data && data.uri) {
					console.log("Photo taken:", data.uri);
					console.log("Photo details:", JSON.stringify(data));
					
					// Check file size if available
					if (data.size) {
						const fileSizeMB = (data.size / (1024 * 1024)).toFixed(2);
						console.log(`Photo size: ${fileSizeMB}MB`);
						
						if (data.size > 5 * 1024 * 1024) { // 5MB
							this.$app.$def.showToast(`ÁÖßÁâáËæÉÂ§ß(${fileSizeMB}MB)ÔºåÂ§ÑÁêÜÂèØËÉΩÈúÄË¶ÅÊõ¥ÈïøÊó∂Èó¥`);
						}
					}
					
					// Store the entire image data object (not just URI)
					this.currentImageData = data;
					this.$app.$def.showToast("ÁÖßÁâáÂ∑≤ÊãçÊëÑ");
					
					// Log the stored data
					console.log("Photo data stored in currentImageData:", JSON.stringify(this.currentImageData));
				}
			},
			fail: (data, code) => {
				console.log(`Take photo failed, code = ${code}, data = ${data}`);
				this.$app.$def.showToast("ÊãçÁÖßÂ§±Ë¥•");
			},
			cancel: () => {
				console.log("Take photo cancelled");
			}
		});
	},
	
	removeSelectedImage: function() {
		this.currentImageData = null;
		// Ensure UI is not stuck in processing state when image is removed
		if (this.isProcessingMessage) {
			this.isProcessingMessage = false;
			this.loadingText = "";  // Clear loading text explicitly
			this.resetUIState();
		}
	},

	handleWebSearch: function () {
		this.$app.$def.showToast("ÁΩëÈ°µÊêúÁ¥¢ÂäüËÉΩÂç≥Â∞ÜÊé®Âá∫");
	},

	navigateToSettings: function () {
		// Navigate to settings page
		const router = require("@system.router");
		router.push({
			uri: "pages/settings",
		});
	},
	/**
	 * Format message content for display with markdown support
	 * @param {string} content - The message content
	 * @return {string} - Formatted message content
	 */
	formatMessageContent: function (content) {
		// Use the markdown helper to process the content
		return this.$app.$def.markdownHelper.formatMessageContent(content);
	},

	sendMessage: async function () {
		if (!this.message.trim() && !this.currentImageData) {
			return;
		}

		if (this.isProcessingMessage) {
			return;
		}

		// Hide welcome screen
		this.showWelcome = false;

		// Save the user message and image data before setting processing state
		const userMessage = this.message.trim();
		const imageDataToSend = this.currentImageData;

		// Set processing state with appropriate loading text
		this.isProcessingMessage = true;
		this.processingProgress = 0;
		
		// Only set loading text when we're actually processing something
		if (imageDataToSend) {
			// Get image size information
			let imageSizeMB = 0;
			
			// If imageDataToSend is an object with size property (from recent selection)
			if (typeof imageDataToSend === 'object' && imageDataToSend.size) {
				imageSizeMB = imageDataToSend.size / (1024 * 1024);
			} 
			// Otherwise fetch the file info using stored URI
			else if (typeof imageDataToSend === 'string') {
				// We store the URI string when selecting the image, but need to estimate size
				// QuickApp doesn't provide direct file size access for URIs
				// Using a reasonable default estimate for typical photos
				imageSizeMB = 2.0; // Default estimate of 2MB
			}
			
			this.loadingText = `Ê≠£Âú®ÂàÜÊûêÂõæÁâá(${imageSizeMB.toFixed(1)}MB)ÔºåËØ∑ËÄêÂøÉÁ≠âÂæÖ...`;
			
			// Start a progress indicator for large images
			if (imageSizeMB > 3) {
				this.startProgressIndicator();
			}
		} else if (userMessage) {
			this.loadingText = "Ê≠£Âú®Â§ÑÁêÜ...";
		}

		// Format timestamp
		const now = new Date();
		const timestamp =
			now.getHours().toString().padStart(2, "0") +
			":" +
			now.getMinutes().toString().padStart(2, "0");
		
		console.log('---------- SENDING MESSAGE ----------');
		if (userMessage) {
			console.log('Text message:', userMessage);
		}
		
		if (imageDataToSend) {
			if (typeof imageDataToSend === 'object') {
				console.log('Image data available for sending:', JSON.stringify(imageDataToSend));
				console.log('Image URI:', imageDataToSend.uri);
				console.log('Image size:', imageDataToSend.size ? (imageDataToSend.size / (1024 * 1024)).toFixed(2) + 'MB' : 'unknown');
				console.log('Is internal URI?', imageDataToSend.uri && imageDataToSend.uri.startsWith('internal://'));
			} else {
				console.log('Image data available for sending:', imageDataToSend);
				console.log('Image data type:', typeof imageDataToSend);
				console.log('Is internal URI?', imageDataToSend.startsWith && imageDataToSend.startsWith('internal://'));
			}
		}

		// Add user message to messages array (including image if present)
		const formattedContent = this.formatMessageContent(userMessage);
		
		// Store image data properly in messages
		// For backward compatibility and storage efficiency, only store the URI in the messages array
		const imageUri = imageDataToSend && (typeof imageDataToSend === 'object' ? imageDataToSend.uri : imageDataToSend);
		
		this.messages.push({
			role: "user",
			content: formattedContent,
			timestamp: timestamp,
			imageData: imageUri
		});

		// Clear input and image
		this.message = "";
		this.currentImageData = null;

		try {
			// Add temporary bot message with appropriate loading text
			const loadingMessage = imageDataToSend ? "Ê≠£Âú®ÂàÜÊûêÂõæÁâáÔºåËØ∑Á®çÂÄô..." : "...";
			this.messages.push({
				role: "bot",
				content: loadingMessage,
				timestamp: timestamp
			});

			// Prepare conversation history for the API
			// Exclude the temporary bot message we just added
			const conversationHistory = this.messages.slice(0, -1);

			// Call the API with message history and image data
			// Extract the URI if imageDataToSend is an object
			const imageUri = imageDataToSend && (typeof imageDataToSend === 'object' ? imageDataToSend.uri : imageDataToSend);
			
			const botResponse = await callChatbotAPI(
				userMessage,
				conversationHistory,
				imageUri
			);

			// Replace the temporary message with the actual response
			this.messages.pop(); // Remove temporary message
			
			// Format the bot response with markdown support
			const formattedContent = this.formatMessageContent(botResponse);
			this.messages.push({
				role: "bot",
				content: formattedContent,
				timestamp: timestamp
			});

			// Scroll to the bottom to show new message
			try {
				this.$element("chat-content-list").scrollTo({
					index: this.messages.length - 1,
				});
			} catch (error) {
				console.error("Failed to scroll to bottom:", error);
			}
		} catch (error) {
			console.error("API call failed:", error);

			// Replace loading message with error
			this.messages.pop(); // Remove temporary message
			
			// Provide more specific error messages based on the error
			let errorMessage = SYSTEM.CHAT.errorMessage;
			if (error.message && error.message.includes('2001')) {
				// Code 2001 is typically timeout
				if (imageDataToSend) {
					// Get image size for error message
					let imageSizeMB = 0;
					if (typeof imageDataToSend === 'object' && imageDataToSend.size) {
						imageSizeMB = imageDataToSend.size / (1024 * 1024);
					} else {
						// Default size estimate if we don't have actual size
						imageSizeMB = 2.0;
					}
					errorMessage = `ÂõæÁâáÂàÜÊûêË∂ÖÊó∂(${imageSizeMB.toFixed(1)}MB)„ÄÇÂª∫ËÆÆÔºö1) ÈáçËØï‰∏ÄÊ¨° 2) ‰ΩøÁî®Êõ¥Â∞èÁöÑÂõæÁâá 3) Ê£ÄÊü•ÁΩëÁªúËøûÊé•„ÄÇÊ≥®ÊÑèÔºöÂπ≥Âè∞Â∑≤ÈÖçÁΩÆ15ÂàÜÈíüË∂ÖÊó∂„ÄÇ`;
				} else {
					errorMessage = "ËØ∑Ê±ÇË∂ÖÊó∂ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÈáçËØï";
				}
			}
			
			// Format the error message with markdown support
			const formattedContent = this.formatMessageContent(errorMessage);
			this.messages.push({
				role: "bot",
				content: formattedContent,
				timestamp: timestamp,
				isError: true
			});

			// Show error toast with specific message
			const toastMessage = imageDataToSend ? "ÂõæÁâáÂàÜÊûêÂ§±Ë¥•" : "Êó†Ê≥ïËøûÊé•Âà∞ÊúçÂä°Âô®";
			this.$app.$def.showToast(toastMessage);

			// Scroll to the bottom to show error message
			try {
				this.$element("chat-content-list").scrollTo({
					index: this.messages.length - 1,
				});
			} catch (error) {
				console.error("Failed to scroll to bottom:", error);
			}
		} finally {
			// Reset processing state using utility function
			this.resetUIState();
			
			// If we don't have a conversation ID yet, generate one
			if (!this.currentConversationId) {
				this.currentConversationId = this.$app.$def.chatHistoryHelper.generateConversationId();
			}
			
			// Save the conversation if we have messages
			if (this.messages.length > 0) {
				this.saveCurrentConversation().catch(error => {
					console.error('Failed to save conversation after message:', error);
				});
			}
		}
	},

	// Progress indicator for long operations
	startProgressIndicator: function() {
		this.processingProgress = 0;
		this.progressInterval = setInterval(() => {
			this.processingProgress += 1;
			if (this.processingProgress >= 100) {
				this.processingProgress = 10; // Reset but keep some progress
			}
			
			// Update loading text with progress
			const baseText = this.loadingText.split('(')[0] + '(' + this.loadingText.split('(')[1].split(')')[0] + ')';
			this.loadingText = `${baseText} - Â§ÑÁêÜ‰∏≠... ${this.processingProgress}%`;
		}, 2000); // Update every 2 seconds
	},

	stopProgressIndicator: function() {
		if (this.progressInterval) {
			clearInterval(this.progressInterval);
			this.progressInterval = null;
		}
		this.processingProgress = 0;
	},

	// Reset UI state utility function
	resetUIState: function() {
		this.isProcessingMessage = false;
		this.loadingText = ""; // IMPORTANT: Always clear loading text when resetting UI state
		this.stopProgressIndicator();
		
		// Force update the UI to ensure loading indicator disappears
		this.$forceUpdate && this.$forceUpdate();
	},
};
</script>

<style lang="less">
@import "../../common/styles/theme.less";
// TODO modern design
// TODO change tool button
// TODO make welcome message more friendly

.page {
	flex-direction: column;
	width: 100%;
	height: 100%;
	box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
		0 2px 4px -2px rgba(0, 0, 0, 0.1);
	background-color: @background-color;
}

/* Header Styles */
.chat-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 12px 16px;
	background-color: @component-background;
	border-bottom: 1px solid @border-color;
}

.chat-header-title {
	font-size: @font-size-xlarge;
	font-weight: bold;
	color: @text-color-primary;
}

.header-button {
	padding: @spacing-small;
	border-radius: 12px;
	background: none;
	width: 72px;
	height: 72px;
	display: flex;
	justify-content: center;
	align-items: center;
}

/* SVG icons will use their own styling */

/* Content Area Styles */
.chat-content {
	flex: 1;
	overflow-y: scroll;
	padding: 20px 16px;
	display: flex;
	flex-direction: column;
}

.chat-welcome {
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	padding: 32px;
	margin: auto;
	width: 100%;
	max-width: 600px;
}

.logo-container {
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100px;
	height: 100px;
	background-color: @primary-color;
	border-radius: 50px;
	margin-bottom: 20px;
	box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
		0 4px 6px -4px rgba(0, 0, 0, 0.1);
}

.logo-text {
	font-size: @font-size-xxlarge;
	font-weight: bold;
	color: @text-color-inverse;
	text-align: center;
}

.welcome-title {
	font-size: @font-size-xlarge;
	font-weight: bold;
	color: @primary-color;
	margin-bottom: 12px;
}

.welcome-message-container {
	display: flex;
	flex-direction: column;
	align-items: center;
	width: 100%;
	padding: 16px 0;
	margin-top: 8px;
}

.welcome-message {
	font-size: @font-size-medium;
	color: @text-color-secondary;
	text-align: left;
	margin-bottom: 10px;
	width: 100%;
}

/* Chat Messages Styles */
.chat-messages-list {
	flex-direction: column;
	width: 100%;
}

.user-message,
.bot-message {
	display: flex;
	flex-direction: column;
	margin: 10px 0;
	padding: 12px 16px;
	border-radius: 16px;
	width: 90%;
}

.user-message {
	background-color: @primary-color-light;
	align-self: flex-end;
	margin-left: 10%;
}

.bot-message {
	background-color: @component-background;
	border: 1px solid @border-color;
	align-self: flex-start;
	margin-right: 10%;
}

.message-timestamp {
	display: flex;
	align-items: center;
	margin-bottom: 6px;
}

.timestamp-text {
	font-size: @font-size-xsmall;
	color: @text-color-tertiary;
}

.message-content-container {
	display: flex;
	flex-direction: column;
	width: 100%;
	padding: 4px 0;
}

.message-text-wrapper {
	display: flex;
	flex-direction: column;
	width: 100%;
}

.message-text-content {
	font-size: @font-size-medium;
	color: @text-color-primary;
	margin: 4px 0;
	padding: 4px 0;
	width: 100%;
	text-align: left;
	/* Ensure text breaks at appropriate points */
	flex-wrap: wrap;
	white-space: pre-wrap;
}

/* We're using a simpler approach for markdown, the formatMessageContent 
   function handles the formatting with special markers */

.message-text-markdown {
	width: 100%;
	margin: 4px 0;
	padding: 4px 0;
}

/* Loading Indicator */
.loading-indicator {
	display: flex;
	justify-content: center;
	padding: 10px;
	width: 100%;
}

.loading-text {
	font-size: @font-size-small;
	color: @text-color-tertiary;
}

/* Input Area Styles - Redesigned to match webapp */
.chat-input-area {
	padding: 16px 20px 20px 20px;
	border-top: 1px solid @border-color;
	background-color: @component-background;
	flex-direction: column;
}

/* Toolbar now in a horizontal row above the input */
.toolbar-row {
	display: flex;
	flex-direction: row;
	gap: 16px;
	margin-bottom: 16px;
	padding: 0 4px;
}

.toolbar-button {
	display: flex;
	flex-direction: row;
	align-items: center;
	padding: @spacing-medium @spacing-large;
	border-radius: 12px;
	background-color: @background-color;
	border: 1px solid @border-color;
}

.icon-container {
	display: flex;
	justify-content: center;
	align-items: center;
	width: 48px;
	height: 48px;
	margin-right: @spacing-medium;
}

.toolbar-icon {
	font-size: @font-size-xxlarge;
	color: @text-color-tertiary;
}

.toolbar-text {
	font-size: @font-size-medium;
	color: @text-color-tertiary;
}

/* Image preview styles */
.image-preview-container {
	width: 100%;
	margin: 10px 0;
	position: relative;
	border-radius: 16px;
	border: 1px solid @border-color;
	padding: 8px;
	background-color: @background-color;
}

.preview-image {
	width: 240px;
	height: 240px;
	object-fit: contain;
	border-radius: 8px;
}

.remove-image-button {
	position: absolute;
	top: 8px;
	right: 8px;
	width: 48px;
	height: 48px;
	border-radius: 24px;
	background-color: rgba(0, 0, 0, 0.5);
	display: flex;
	align-items: center;
	justify-content: center;
}

.remove-icon {
	color: white;
	font-size: @font-size-medium;
}

/* Message image styles */
.message-image {
	width: 200px;
	height: 200px;
	margin-bottom: 8px;
	border-radius: 8px;
	object-fit: contain;
}

.input-area-wrapper {
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 16px;
	width: 100%;
}

.text-input {
	flex: 1;
	padding: 16px;
	font-size: @font-size-medium;
	background-color: @background-color;
	border: 1px solid @border-color;
	border-radius: 12px;
	color: @text-color-primary;
}

.send-button {
	width: 80px;
	height: 80px;
	border-radius: 40px;
	background-color: @primary-color;
	display: flex;
	justify-content: center;
	align-items: center;
}

.send-icon {
	color: @text-color-inverse;
	font-size: @font-size-xlarge;
}

/* Add sidebar overlay styles */
.sidebar-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 999;
}

.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 75%;
  height: 100%;
  background-color: @component-background;
  z-index: 1000;
  flex-direction: column;
  transition: transform 0.3s ease-in-out;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.sidebar-header {
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: space-between;
	padding: 16px;
	border-bottom: 1px solid @border-color;
}

.sidebar-title {
	font-size: @font-size-large;
	font-weight: bold;
	color: @text-color-primary;
}

.sidebar-content {
	flex: 1;
	padding: 16px;
	overflow-y: scroll;
}
// TODO adjust position of history list placeholder
.sidebar-empty-text {
	color: @text-color-tertiary;
	font-size: @font-size-medium;
	text-align: center;
	margin-top: 32px;
}

/* Conversation list styles */
.conversation-list {
	flex-direction: column;
	width: 100%;
}

.conversation-item {
	display: flex;
	flex-direction: row;
	justify-content: space-between;
	align-items: center;
	padding: 16px 8px;
	margin: 4px 0;
	border-radius: 8px;
	background-color: @background-color;
}

.conversation-info {
	flex: 1;
	display: flex;
	flex-direction: column;
}

.conversation-title {
	font-size: @font-size-medium;
	color: @text-color-primary;
	margin-bottom: 4px;
	font-weight: 500;
}

.conversation-preview {
	font-size: @font-size-small;
	color: @text-color-secondary;
	margin-bottom: 4px;
}

.conversation-timestamp {
	font-size: @font-size-xsmall;
	color: @text-color-tertiary;
}

.delete-conversation-btn {
	width: 48px;
	height: 48px;
	border-radius: 24px;
	background-color: @background-color;
	display: flex;
	justify-content: center;
	align-items: center;
}

.delete-icon {
	font-size: @font-size-medium;
	color: @error-color;
}
// TODO beautify sidebar footer
.sidebar-footer {
	padding: 16px;
	border-top: 1px solid @border-color;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: space-between;
}

.account-info {
	display: flex;
	flex-direction: row;
	align-items: center;
}

.account-avatar {
	width: 60px;
	height: 60px;
	border-radius: 30px;
	background-color: @primary-color;
	display: flex;
	justify-content: center;
	align-items: center;
	margin-right: 12px;
}

.avatar-text {
	color: @text-color-inverse;
	font-size: @font-size-large;
}

.account-name {
	font-size: @font-size-medium;
	color: @text-color-primary;
}

.settings-button {
	width: 60px;
	height: 60px;
	border-radius: 30px;
	background-color: @background-color;
	display: flex;
	justify-content: center;
	align-items: center;
}

.settings-icon {
	font-size: @font-size-large;
	color: @text-color-tertiary;
}

.close-button {
	border-radius: 50%;
}
</style>